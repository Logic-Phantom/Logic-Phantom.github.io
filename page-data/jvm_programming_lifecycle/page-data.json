{"componentChunkName":"component---src-templates-post-template-tsx","path":"/jvm_programming_lifecycle/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>프로그래밍의 구동 방식: JVM 안에서 일어나는 일들</h1>\n<blockquote>\n<p>“코드를 작성하고 실행 버튼을 눌렀을 뿐인데, 그 안에서는 무슨 일이 일어날까?”</p>\n</blockquote>\n<p>개발을 시작하면 우리는 보통 IDE(통합개발환경)에서 코드를 작성하고, 저장하고, 실행 버튼을 누릅니다. 하지만 우리가 작성한 그 코드가 어떻게 실제로 프로그램으로 동작하는 걸까요? 이 글에서는 그 과정의 이면을 들여다보며, 특히 Java 언어를 중심으로 JVM 내부의 세계와 메모리의 구체적인 동작 방식을 이야기해보려 합니다.</p>\n<hr>\n<h2>1. Java 코드가 실행되기까지</h2>\n<h3>🧾 Step 1. 소스코드 작성 (<code class=\"language-text\">.java</code>)</h3>\n<p>우리는 보통 이렇게 코드를 작성합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Hello</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드는 <code class=\"language-text\">.java</code> 확장자를 가진 <strong>소스 코드 파일</strong>입니다. 하지만 이 파일은 CPU가 직접 이해하지 못합니다. 우리는 <strong>컴파일</strong>이라는 과정을 거쳐야 합니다.</p>\n<hr>\n<h3>⚙️ Step 2. 컴파일 → 바이트코드 (<code class=\"language-text\">.class</code>)</h3>\n<p>Java 컴파일러(<code class=\"language-text\">javac</code>)는 이 <code class=\"language-text\">.java</code> 파일을 읽어 들여 <strong>바이트코드(Bytecode)</strong> 로 변환합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">javac Hello.java</code></pre></div>\n<p>결과로 <code class=\"language-text\">Hello.class</code>라는 파일이 생성되며, 이 파일은 <strong>JVM만 이해할 수 있는 중간 언어</strong>입니다.</p>\n<hr>\n<h3>🔥 Step 3. JVM에서 실행</h3>\n<p>바이트코드는 JVM(Java Virtual Machine)에 의해 해석되어 실행됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">java</span> Hello</code></pre></div>\n<p>실행하면 JVM이 해당 <code class=\"language-text\">.class</code> 파일을 로딩하고, 내부적으로 메모리를 할당하고, 클래스 로딩을 수행하며, 결국 <code class=\"language-text\">main()</code> 메서드를 찾아 실행하게 됩니다.</p>\n<hr>\n<h2>2. JVM의 구조: 내부는 어떻게 생겼을까?</h2>\n<p>JVM은 단순한 인터프리터가 아닙니다. 그 안에는 아주 복잡하고 정교한 구조가 존재하죠. 핵심 구성 요소는 다음과 같습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+-----------------------------+\n|    Class Loader Subsystem   |\n+-----------------------------+\n|        Runtime Data Area     |\n|  - Method Area               |\n|  - Heap                     |\n|  - Java Stack               |\n|  - PC Register              |\n|  - Native Method Stack      |\n+-----------------------------+\n|        Execution Engine      |\n|  - Interpreter               |\n|  - JIT Compiler              |\n+-----------------------------+</code></pre></div>\n<hr>\n<h2>3. 메모리 구조: Runtime Data Area</h2>\n<p>JVM이 실행되면 다음과 같은 메모리 영역들이 생성됩니다.</p>\n<h3>🧠 1) 메서드 영역 (Method Area)</h3>\n<ul>\n<li>클래스 수준의 정보가 저장됨 (필드, 메서드, static 변수 등)</li>\n<li>모든 스레드가 공유</li>\n<li><code class=\"language-text\">static</code> 변수나 클래스 메타데이터가 여기 저장됨</li>\n</ul>\n<h3>🐘 2) 힙 영역 (Heap)</h3>\n<ul>\n<li><strong>new 키워드로 생성한 객체들</strong>이 저장됨</li>\n<li>GC(Garbage Collector)의 대상</li>\n<li>모든 스레드가 공유</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Person</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 힙에 저장</span></code></pre></div>\n<h3>🧵 3) 스택 영역 (Java Stack)</h3>\n<ul>\n<li>스레드마다 하나씩 존재</li>\n<li><strong>메서드 호출 시 생성되는 프레임</strong>이 쌓임</li>\n<li>지역변수, 매개변수가 저장됨</li>\n<li>메서드가 끝나면 해당 프레임은 pop됨</li>\n</ul>\n<h3>⏱️ 4) PC 레지스터 (Program Counter Register)</h3>\n<ul>\n<li>현재 스레드가 <strong>실행 중인 바이트코드 명령의 주소</strong>를 가리킴</li>\n</ul>\n<h3>🛠️ 5) 네이티브 메서드 스택</h3>\n<ul>\n<li>C/C++ 등의 <strong>native 메서드 호출을 위한 스택</strong></li>\n</ul>\n<hr>\n<h2>4. 실행 엔진: 코드를 실제로 돌리는 힘</h2>\n<h3>1️⃣ 인터프리터 (Interpreter)</h3>\n<ul>\n<li>바이트코드를 한 줄씩 읽고 해석</li>\n<li>빠른 시작이 장점이지만 반복된 실행에서 느림</li>\n</ul>\n<h3>2️⃣ JIT 컴파일러 (Just-In-Time Compiler)</h3>\n<ul>\n<li>자주 실행되는 바이트코드를 네이티브 코드로 변환하여 캐싱</li>\n<li>실행 속도 향상</li>\n<li>JVM이 실행 중인 동안 실시간으로 수행됨</li>\n</ul>\n<hr>\n<h2>5. GC (Garbage Collection): 힙 메모리의 청소부</h2>\n<p>Java는 메모리 관리를 자동으로 해줍니다. 그 중심에는 <strong>GC(Garbage Collector)</strong> 가 있죠.</p>\n<ul>\n<li>더 이상 참조되지 않는 객체들을 주기적으로 탐색해 제거</li>\n<li>다양한 알고리즘 존재 (Mark &#x26; Sweep, Generational GC 등)</li>\n<li>Java 9 이후 <code class=\"language-text\">G1 GC</code>가 기본 채택됨</li>\n</ul>\n<hr>\n<h2>6. 스레드와 동시성</h2>\n<p>JVM은 멀티스레딩을 지원합니다. 각 스레드는 독립적인 스택을 가지며, 힙 영역을 공유합니다. 이를 통해 동시성과 병렬 처리가 가능하지만, <strong>동기화 문제</strong>나 <strong>데드락</strong> 등의 이슈도 함께 생길 수 있죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 한 번에 한 스레드만 접근 가능</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>7. 실행이 끝나면?</h2>\n<p>JVM이 모든 작업을 마치면, 스택 영역과 힙 영역은 <strong>GC 또는 JVM 종료와 함께 정리</strong>됩니다. 우리가 쓴 <code class=\"language-text\">System.exit()</code> 나 <code class=\"language-text\">main()</code> 종료는 곧 프로그램의 생명 주기의 끝을 의미합니다.</p>\n<hr>\n<h2>마무리하며: 코드를 안다는 것의 의미</h2>\n<p>많은 초보 개발자들은 “코드를 잘 짜는 것”을 문법이나 라이브러리의 사용법으로 이해합니다. 그러나 진짜 실력은 <strong>코드가 어떻게 실행되는지를 이해하는 것</strong>에서 나옵니다.</p>\n<ul>\n<li>클래스가 언제 메모리에 올라가는지</li>\n<li>객체는 어디에 저장되는지</li>\n<li>GC가 어떤 기준으로 동작하는지</li>\n<li>성능에 영향을 미치는 메모리 구조는 어떤지</li>\n</ul>\n<p>이런 것들을 이해하고 나면, 코드가 단순히 “돌아가기만” 하는 것이 아니라, <strong>어떻게 잘 돌아가게 할 것인가</strong>에 대한 통찰을 얻을 수 있습니다.</p>\n<hr>\n<blockquote>\n<p>💡 “눈에 보이지 않는 실행 흐름까지 이해할 때, 우리는 진짜 개발자가 된다.”</p>\n</blockquote>","frontmatter":{"title":"프로그래밍의 구동 방식","summary":"JVM 안에서 일어나는 일들","date":"2025.07.24.","categories":["Java","Web"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD1klEQVR42p1S609bZRw+f4UxfjL6xQ8mS5aobCo6Iy4mipvDtNsY4hxsyZCC8ygJl67ImLZQesoxpT0FBsUyGJdx6Si3DtpChwJjbaVcejkr0MtpT9tTaHt6fT0MIXHRD5o8yfvh+T2X3/u+UCbm+9+ADo50lDjAv80dUM8N/CUGcT+g/SAZ+AdllABxMp2kEjQFkqFMjPibOBnxeretIQK32yyxsIdxOaL3HeMkvevZ0P1q7OcR+EomEcgc5kMMHaNcdqsZt5ruj2sMi78z+UclaWonRYdsj/qW7lzfHEeWOkojlPvIfV8cD7ut68YH6jGDQbeNrzFFDjL3AttBr4OOBqwP5dbROr/VYO4oDvtwcBi+L6bD7lXz8sysZnHRYN80J/c8KebyYr4wuRUN7YA0hdvMg0jJ8K2zc2OKdILKRL1Hyb7Ersfyx2OTccnt3CDctkw6CBhkQhHKFQ27AIghbYrPr1VegXlsDm8v4AQJ8mAv6NntEZkUBQBN06R6Vj8yrR2amhnRzKq1cxO6+XHtPHLnXrVIDvOlw2o10zSx50lHnyUzHkyOenKiGOYKMYXsnspmX1vftKyYntShbfBPqEY/59yyk74tSc9oj3oagHCQwCnfU8YFYjr43fbjp9n5XxXnflk6pJll6EyCvMETvPzOuVez83Ivf+tx2ZheStVk54AKgEh8zxsinMzX2N85HvHW1tUvjHR2KTr6xjUA7C4//u3Nz75ukrY3SFq5AvTuwBBIka39vW0DPSbLo4UVLYOgzwGBZHBrZ6Nf2f7JmYvcRolaNw9ACHdYPrhQcur89Zz80mMfF2j1uoDPLlSIhV3NaG9LUxcqUqJrG8vQ1KIuD2241SWBxfwCRHx/eoYRM+GDo6q3cgtf/+hCbUMzs4ifxF3OVbNpYfrhuPGJwe9a38YtULlCdhbls+TiQmXLGeTnK3xM3DOBdKuwwYmbLd1cSTc2PHO7c7SutV+ztKzSz8sHRoZm9Xqj0Wpdhcq7sHMIPx9D2G3oaeHtqyh2vkqSw2n8FG4uvCk5VlifC4slg1M/tg/yH8zU9o1x0I4a5XDj5Jx53QzBSvnFNuQSJuL2ypC7LdWtv5SLOovq20v47ZLuoWwOeq1OSu+6U6mwn8BJ31PS7/R6HITHkYgR0Gt5V7NuVGRx4NKKqvLvKj/M/+bdotr3i3jHWfCL71166VThC9kFr+RcfuOL0hPsspPsshMszkkW5212WRaLA1UJsUqBtLpR9r1ACgukVSI5T9xaI8Kqm2Q1IjkX2UelUPaDoKXiOTRIIebRAYgeIvKf8CezHZiMZUdAJAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/44674dc7369960cff3b45c1ca42bcf0b/34104/javaPro.png","srcSet":"/static/44674dc7369960cff3b45c1ca42bcf0b/5ce94/javaPro.png 256w,\n/static/44674dc7369960cff3b45c1ca42bcf0b/8a20a/javaPro.png 512w,\n/static/44674dc7369960cff3b45c1ca42bcf0b/34104/javaPro.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/44674dc7369960cff3b45c1ca42bcf0b/99d55/javaPro.webp 256w,\n/static/44674dc7369960cff3b45c1ca42bcf0b/3591c/javaPro.webp 512w,\n/static/44674dc7369960cff3b45c1ca42bcf0b/e306d/javaPro.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}},"publicURL":"/static/44674dc7369960cff3b45c1ca42bcf0b/javaPro.png"}}}}]}},"pageContext":{"slug":"/jvm_programming_lifecycle/"}},"staticQueryHashes":[],"slicesMap":{}}