{"componentChunkName":"component---src-templates-post-template-tsx","path":"/backend_api_comparison/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>📌 백엔드 (Backend)</h1>\n<h2>REST vs GraphQL vs gRPC</h2>\n<h3>언제 어떤 방식을 선택해야 하는가</h3>\n<hr>\n<h2>1. 서론: API 통신의 진화</h2>\n<p>백엔드와 프론트엔드, 혹은 서비스 간의 통신을 위해 가장 중요한 요소는\n<strong>API 설계 방식</strong>입니다.<br>\n오늘날 대표적으로 사용되는 방식은 다음 세 가지입니다.</p>\n<ul>\n<li><strong>REST (Representational State Transfer)</strong></li>\n<li><strong>GraphQL</strong></li>\n<li><strong>gRPC (Google Remote Procedure Call)</strong></li>\n</ul>\n<p>각각은 다른 철학과 설계 원칙을 가지고 있으며, 서비스 규모와 요구사항에\n따라 적합성이 달라집니다.</p>\n<hr>\n<h2>2. REST (Representational State Transfer)</h2>\n<h3>개념</h3>\n<ul>\n<li>2000년대 초반부터 널리 사용된 아키텍처 스타일</li>\n<li>**리소스(자원)**를 중심으로 한 설계 (<code class=\"language-text\">/users</code>, <code class=\"language-text\">/posts/:id</code> 등)</li>\n<li>HTTP 메서드(GET, POST, PUT, DELETE)를 활용</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>단순하고 직관적 → 학습 비용이 낮음</li>\n<li>HTTP 표준 기반 → 인프라 친화적</li>\n<li>캐싱, 로깅, 보안 등 다양한 에코시스템 지원</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>Over-fetching: 필요 없는 데이터까지 불필요하게 가져옴</li>\n<li>Under-fetching: 원하는 데이터를 얻기 위해 여러 번 호출 필요</li>\n<li>대규모 API 스펙 관리 어려움</li>\n</ul>\n<h3>사용 사례</h3>\n<ul>\n<li>CRUD 기반 서비스 (게시판, 전자상거래)</li>\n<li>빠른 프로토타이핑 및 범용 API</li>\n</ul>\n<hr>\n<h2>3. GraphQL</h2>\n<h3>개념</h3>\n<ul>\n<li>2015년 Facebook에서 공개</li>\n<li>클라이언트가 필요한 데이터 구조를 직접 정의해서 요청 가능</li>\n<li>단일 엔드포인트(<code class=\"language-text\">/graphql</code>)에서 다양한 쿼리 처리</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>Over-fetching / Under-fetching 문제 해결</li>\n<li>스키마 기반 → 강력한 타입 시스템 제공</li>\n<li>API 문서화 및 개발자 경험(DX) 향상 (GraphiQL, Playground)</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>서버 구현 복잡도 증가</li>\n<li>캐싱이 어렵고, N+1 쿼리 문제 발생 가능</li>\n<li>단순한 API에는 오히려 과한 선택</li>\n</ul>\n<h3>사용 사례</h3>\n<ul>\n<li>복잡한 UI를 가진 프론트엔드 (대시보드, SNS)</li>\n<li>다양한 클라이언트(Web, iOS, Android)에서 동일 API 활용</li>\n</ul>\n<hr>\n<h2>4. gRPC (Google Remote Procedure Call)</h2>\n<h3>개념</h3>\n<ul>\n<li>Google에서 개발한 고성능 RPC 프레임워크</li>\n<li>Protocol Buffers (protobuf) 기반 직렬화 사용</li>\n<li>HTTP/2 기반 → 멀티플렉싱, 스트리밍 지원</li>\n</ul>\n<h3>장점</h3>\n<ul>\n<li>빠른 직렬화/역직렬화 → 성능 우수</li>\n<li>양방향 스트리밍 가능 → 실시간 서비스에 적합</li>\n<li>명확한 인터페이스 정의(IDL) → 타입 안정성 보장</li>\n</ul>\n<h3>단점</h3>\n<ul>\n<li>디버깅 및 테스트 도구 부족 (REST만큼 친숙하지 않음)</li>\n<li>브라우저 직접 지원 제한 (프록시 필요)</li>\n<li>초기 학습 및 인프라 설정 부담</li>\n</ul>\n<h3>사용 사례</h3>\n<ul>\n<li>마이크로서비스 간 통신</li>\n<li>실시간 스트리밍 서비스 (채팅, IoT, 게임)</li>\n<li>대규모 트래픽이 요구되는 백엔드 시스템</li>\n</ul>\n<hr>\n<h2>5. 비교 정리</h2>\n<hr>\n<p>구분       REST                GraphQL                  gRPC</p>\n<hr>\n<p>철학       리소스 기반         클라이언트 주도 쿼리     함수 호출 기반</p>\n<p>전송       HTTP/1.1            HTTP/1.1 (대부분)        HTTP/2 + Protobuf\n프로토콜</p>\n<p>성능       보통                보통~좋음               매우 우수</p>\n<p>학습       낮음                중간                     높음\n난이도</p>\n<p>캐싱       용이                어려움                   상대적으로 어려움</p>\n<h2>적합 사례  범용 API, 간단한    복잡한 UI, 다양한        마이크로서비스,\nCRUD                클라이언트 지원          실시간 스트리밍</h2>\n<hr>\n<h2>6. 선택 기준 (Best Practice)</h2>\n<ol>\n<li><strong>REST</strong>\n<ul>\n<li>소규모 프로젝트, 단순 CRUD, 빠른 개발이 필요한 경우\\</li>\n<li>캐싱 및 HTTP 친화성이 중요한 경우</li>\n</ul>\n</li>\n<li><strong>GraphQL</strong>\n<ul>\n<li>다양한 클라이언트에서 세밀한 데이터 제어가 필요한 경우\\</li>\n<li>복잡한 UI/대시보드, 모바일 최적화가 필요한 경우</li>\n</ul>\n</li>\n<li><strong>gRPC</strong>\n<ul>\n<li>마이크로서비스 아키텍처, 내부 서비스 간 통신\\</li>\n<li>대규모 트래픽, 낮은 지연시간이 중요한 경우\\</li>\n<li>실시간 스트리밍 서비스(채팅, IoT, 게임)</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>7. 심화 관점: 전문가 토론 포인트</h2>\n<ul>\n<li><strong>보안</strong>\n<ul>\n<li>REST/GraphQL: OAuth 2.0, JWT와 친화적\\</li>\n<li>gRPC: TLS 기반 보안은 기본이지만 세션 기반 인증은 직접 구현 필요</li>\n</ul>\n</li>\n<li><strong>모니터링 및 운영</strong>\n<ul>\n<li>REST는 성숙한 툴이 많음 (APM, 로깅, API Gateway)\\</li>\n<li>GraphQL은 Observability가 상대적으로 미흡 → Federation 필요\\</li>\n<li>gRPC는 분산 트레이싱(Jaeger, OpenTelemetry)과 잘 어울림</li>\n</ul>\n</li>\n<li><strong>아키텍처 트렌드</strong>\n<ul>\n<li><strong>단일 서비스</strong> → REST 권장\\</li>\n<li><strong>대규모 프론트엔드/모바일 지원</strong> → GraphQL 권장\\</li>\n<li><strong>마이크로서비스/실시간 처리</strong> → gRPC 권장</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>8. 결론</h2>\n<p>API 설계에는 정답이 없습니다.<br>\n<strong>서비스의 성격, 팀의 역량, 운영 환경</strong>에 따라 최적의 선택이 달라집니다.</p>\n<ul>\n<li>빠른 개발과 범용성: <strong>REST</strong></li>\n<li>클라이언트 친화적 데이터 제어: <strong>GraphQL</strong></li>\n<li>고성능·실시간·마이크로서비스: <strong>gRPC</strong></li>\n</ul>\n<p>👉 결국 중요한 것은 **기술 자체보다 “문제를 해결하는 적합성”**입니다.</p>\n<hr>","frontmatter":{"title":"백엔드에서의 API 통신 선택","summary":"API 설계에 대해 정답을 찾아서","date":"2025.08.29.","categories":["Web","Server"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACeElEQVR42mVS227aQBDlJ/shfegH9C2PTR8aqVLSKmloFDUkhARzvxgK2AZzCQaC8fqGISkJiS8YjLG3Y5KqlSrtjkezPnvO7JmQZyDfQKs5v3gYWrNb/a7v27K/lO057y8VvBpvFpL9yG8MhFcKHHk6AsjLCrnPAlRrVPHT4bfT6AVFFSEnyzkiTRTIzGXy+kcs+vX0tMmWod5s/sQLydOFF8pQ8DFFoFWEpopaQDgbd6dSZ9inGZrMFdMSz0J9KnfulJtf6g02xb/Mr5kpBiJdLYhrzXoafQ5/D0ciiWxiAgB/6jsqXo+3soX/wAayH4Zso8T3GU1sKSOW61QVvjlGLRU1p1J7NGD6XQpE+SZaP4/+AesIO6prSQOOgsbgitGgPujRdLtcrRcb9RJ3U2MYEiqOJWFv4rtjbys+tNEFbMutduX47KxcyXsgG17bFCG6V3Wv2/cdBa5WxfZ1Kk5kiHiagMS4H2BLDMGea9zuwVH4PPLh4JDr1rAjr+S+/qVkRmv6UdmIU9hVcoVU5PoylU1E47GTi3M0bOClEsILWRVauweH6XxyZ28fzrCjOErf2C/5S9EmWTNG4Y3CMCVt0uN7dIS46g4bwm09AL84FiWu9o7Db96+f7fzEVvIu+eXJ1X7uLI8qjjFJl4rbL2UJ9Ps1u10LqmJbegLekagfDSs0zSZzCZuOQrb0p3cuZ9xsyylsowgs+7TCBzSUIumitVaYSK1AQLAgBkyKMFLUBQ5n/TwUgafiFT8LBVLFZKX8Rg4BCZnCqmLeCxPZh41bgsWXn32F9ImGBWYNuQ9C5D7lgiEQTQQjDC05jzx8BvMiftnvH8DamCasINCTCQAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/399048644eb580f9dbf198446364ba5d/4d776/BackendAPI.png","srcSet":"/static/399048644eb580f9dbf198446364ba5d/4a410/BackendAPI.png 384w,\n/static/399048644eb580f9dbf198446364ba5d/f5189/BackendAPI.png 768w,\n/static/399048644eb580f9dbf198446364ba5d/4d776/BackendAPI.png 1536w","sizes":"(min-width: 1536px) 1536px, 100vw"},"sources":[{"srcSet":"/static/399048644eb580f9dbf198446364ba5d/b642b/BackendAPI.webp 384w,\n/static/399048644eb580f9dbf198446364ba5d/c9564/BackendAPI.webp 768w,\n/static/399048644eb580f9dbf198446364ba5d/18b4b/BackendAPI.webp 1536w","type":"image/webp","sizes":"(min-width: 1536px) 1536px, 100vw"}]},"width":1536,"height":1024}},"publicURL":"/static/399048644eb580f9dbf198446364ba5d/BackendAPI.png"}}}}]}},"pageContext":{"slug":"/backend_api_comparison/"}},"staticQueryHashes":[],"slicesMap":{}}